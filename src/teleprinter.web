

So this might be something useful:

<<*>>=

<<globals>>
<<functions>>

int main (string[] argv) {
    string input = "";
    <<read in file>>
    
    <<set globals>>
    
    
    
    string output;
    <<do parsing>>
    
    
    <<save output>>
    
    return 0;
}
@


Parsing:

<<do parsing>>=
    
    output = parse_level (input);
    if (output == null) {
        stderr.printf ("Errors occured!\n");
    }

@





\section {parsing & building}

This is realized with two functions, parse_level() and parse_command(), which recursively call each other; one handles single commands, the other a 'level', i.e. an arbitrary amount of text with commands in it.
The entire document is such a level.

<<functions>>=
string? parse_level (string input) {
    
    string output = "";
    
    MatchInfo m;
    command_reg.match (input, 0, out m);
    
    int p = 0;
    do {
        int start, end;
        m.fetch_pos (0, out start, out end);
        output += m.get_string().slice (p, start);
        p = end;
        output += parse_command (m.fetch (0));
    }
    while (m.next ());
    
    return output;
}

string? parse_command (string command) {

    MatchInfo m;
    c_name_reg.match (command, 0, out m);
    
    string name = m.fetch (0);
    
    
    <<execute command>>
    
    return null;

}
@

There are two regular expressions that are required for this, one to match a single command and one to match a command's name:

<<globals>>=
Regex command_reg;
Regex c_name_reg;
@

<<set globals>>=
command_reg = /\\(\w*)\b(\s*{((?R)|.*)})*/;
c_name_reg = /\\\w*\b/;
@


A single command can either be a basic one (i.e. an \emph{assembly command}) or it might be defined somewhere earlier in the document with the \\newcommand assembly command.

An assembly command is defined directly in the code; as such, it is implemented by one branch in this switch.

<<execute command>>=
switch (name) {
    case "\\begin":
        <<begin>>
    case "\\end":
        <<\end>>
    case "\\emph":
        <<\emph>>
    case "\\title":
        <<set title>>
    case "\\maketitle":
        <<\maketitle>>
    case "\\hr":
        <<\hr>>
    case "\\documentclass":
        <<\documentclass>>
    case "\\image":
    	<<\image>>
	case "\\raw":
		<<\raw>>
	case "\\text":
		<<\text>>
	case "\\enquote":
		<<\enquote>>
	case "\\link":
		<<\link>>
	case "\\center":
		<<\center>>
    default:
        <<lookup command>>
}
@


If a command is none of these, then it might be one that is defined within the document. This isn't supported yet, meaning that this will invariably result in an error:

<<lookup command>>=
    stderr.printf ("undefined command '%s'!\n", name);
    return null;
@

In case of error, null is returned (which will then chain up until the top-level parse_level() call returns null and signifies an error).


\subsection {assembly commands}

Each basic command consists of a basic chunk of code:

\subsubsection {the \\emph command}

<<\emph>>=
    return "\<em\>%s\</em\>".printf (get_single_argument (command));

@



\subsubsection {\\title}

this sets the document's title.

<<set title>>=
    string arg = get_single_argument (command);
    title = arg;
    return "";
@

<<globals>>=
string title;
@

<<set globals>>=
title = "";
@

\subsubsection {\\maketitle}

<<\maketitle>>=
    return """
    <div class="box-top">
       <div class="title">
         %s
       </div>
    </div>
    <div class="box-main">
    <div class="text">
    """.printf (title);
@


\subsubsection {\\hr}

<<\hr>>=
return """
	</p>
    </div>
    </div>
    <div class="box-main">
    <div class="text">
    <p>
""";
@

\subsubsection {\\image}

Displays the given image from source:

<<\image>>=
string source = get_single_argument (command);
return "%s%s%s".printf("""</p><img src="""", source, """" class="frame"><p align=justify>""");
@


\subsubsection {\\raw}

Interrupts the normal text flow (i.e. ends the paragraph without starting a new one).
Should only be used if there is a legitimate reason for it (e.g. to display special content
that is not text)

This commands should be used together with \\text, which will restart the text flow.

<<\raw>>=
	return """</p>""";
@

\subsubsection {\\text}

<<\text>>=
	return """<p align="justify">""";
@

\subsubsection {\\enquote}

This generates quotes around the text given to it. Should actually be implemented in printer-code, not as assembly â€¦

<<\enquote>>=
	string text = get_single_argument (command);
	return "%s%s%s".printf ("""&ldquo;""", text, """&rdquo;""");
@


\subsubsection {\\link}

<<\link>>=
	string[] text = get_arguments (command);
	return "<a href=\"%s\" class=\"link\">%s</a>".printf (text[1], text[0]);
@


\subsubsection {\\center}

<<\center>>=
	string text = get_single_argument (command);
	return """</p><p align="center">""";
@



\subsubsection {\\begin and \\end}


These are actually surprisingly simple. We just use a hashmap that stores what to do for every known environment (which is easily extensible with a \new command):

<<begin>>=
    string arg = remove_whitespace (get_single_argument (command));
    
    if (!envs.has_key (arg)) {
         stderr.printf ("Unknown environment '%s'.\n", arg);
         return null;
    }
    return envs[arg].begin;
@

<<\end>>=
    string arg = remove_whitespace (get_single_argument (command));
    
    if (!envs.has_key (arg)) {
         stderr.printf ("Unknown environment '%s'.\n", arg);
         return null;
    }
    return envs[arg].end;
@

<<globals>>=

Gee.HashMap <string, env> envs;
@

<<set globals>>=

stdout.printf ("test\n");
envs = new Gee.HashMap <string ,env> ();

<<set assembly envs>>

@

Because all the default values for these tend to be a bit long, I've moved them to appendix A.

This is the type in the actual hashmap, as well as a function to allocate a new one:

<<functions>>=
class env {
    public string begin;
    public string end;
}

env new_env (string begin, string end) {
    env ret = new env ();
    ret.begin = begin;
    ret.end = end;
    return ret;
}

@




<<\documentclass>>=

	return "";
@

Commands sometimes need to use arguments, so here's a function for that, as well as a convenience function for the many commands that just take one of them:

<<functions>>=
string[] get_arguments (string command) {
    string[] ret = new string [0];
    
    MatchInfo m;
    c_args_reg.match (command, 0, out m);
    
    do {
        ret += (/(\{|\})/).replace (m.fetch (0), -1, 0, "");
    } while (m.next ());
    
    
    return ret;
}

string get_single_argument (string command) {
    string[] args = get_arguments (command);
    
    if (args.length != 1) {
        args_error (command, 1);
    }
    return args[0];
}

string remove_whitespace (string input) {
    return (/\s/).replace (input, -1, 0, "");
}
@

Basically, it runs through all the commands and stores them in an array.

There's also a new constant in this, which contains a regular expression to parse single arguments:

<<globals>>=
Regex c_args_reg;
@

<<set globals>>=
c_args_reg = /(?<arg> (\{)([^{}]+|(?&arg))*(\}))/;
@

Some commands expect to get a fixed number of arguments, so here's a handy error function for that:

<<functions>>=
void args_error (string command, int number, int found=0) {
    stderr.printf ("%s takes exactly %d arguments, not %d!\n", command, number, found);
}
@





\section {input}

Here's some code to read in the input file:

<<read in file>>=
	<<check for arguments>>
    File finput = File.new_for_path (argv[1]);
    <<check if input exists>>
    
    try {
        <<read lines of input>>
    } catch {
        stderr.printf ("File Error");
        return 1; // again, terminate in case of error
    }
    
@


<<check for arguments>>=
	if (argv.length != 2) {
		stderr.printf ("this programm takes exactly one input file!\n");
		return 1;
	}
@

<<read lines of input>>=
    var dis = new DataInputStream (finput.read ());
    string line;
    // Read lines until end of file (null) is reached
    while ((line = dis.read_line (null)) != null) {
        input += "%s\n".printf (line);
    }
@

Before we do that, of course, we need to check if any file actually exists:

<<check if input exists>>=
    if (!finput.query_exists ()) {
        stderr.printf ("Input doesn't exist!\n");
        return 1;
    }
@




\section {Saving stuff}

<<save output>>=
    string filename;
    <<get a nice output name>>
    
    try {
        var file_out = File.new_for_path (filename);

        // delete if the file already exists
        if (file_out.query_exists ()) {
            file_out.delete ();
        }
        
        var dos = new DataOutputStream (file_out.create (FileCreateFlags.REPLACE_DESTINATION));
        
        dos.put_string (output); // put the whole thing out
        
    } catch (Error e) {
        stderr.printf ("%s\n", e.message);
        return 1; // this would be a file error, ergo error code 1.
    }
@

Since neither overwriting our input file nor having a fixed output file name is a nice option, here's some code to keep the input's file name, but change the extension.

<<get a nice output name>>=

    string[] temp = argv[1].split(".");
    filename = "%s.html".printf (temp[0]);
@




\section {Appendix A}

<<set assembly envs>>=

envs["document"] = new_env ("%s\n%s\n%s".printf("""
      <html>
      	<head> 
      	<title>~stuebinm</title>""",
      	styles,
      	"""</head>
        <body>
        <div class="background">
    </div>
  
    <header class="box-header">
        <div class="header-title">
        /~stuebinm
        </div>
        <div class="header-quote">
        &ldquo;Beware of bugs in the above code; I have only proved it correct, not tried it.&rdquo; &mdash; D. E. Knuth
        </div>
    </header>
  
          <div class="content"\> <p>
    """), 
    """
    		  </p>
            </div>
          </div>
        </body>
      </html>
    """);

@

<<globals>>=
const string styles = """
	<style>
    @font-face {
        font-family: "CM Bold";
        src: url("fonts/cmunbmr.ttf");
      font-weight: normal; 
      font-style: normal;
    }
    @font-face {
        font-family: "CM Serif";
        src: url("fonts/cmunrm.ttf");
      font-weight: normal; 
      font-style: normal;
    }
    @font-face {
        font-family: "CM Typewriter";
        src: url("fonts/cmunorm.ttf");
      font-weight: italic; 
      font-style: normal;
    }
    .initial {
      float: left;
      padding: 0.27em 5px 0 0;
      font-size: 340%;
      font-weight: bold;
      line-height: 0.5;
    }
    .box-top {
      position: relative;
      width: 100%;
      background-color: #ddd;
      border: 1px solid #444;
      text-align: center;
    }
    .box-main {
      position: relative;
      width: 100%;
      background-color: #fff;
      border: 1px solid #444;
      border-top-style: none;
      text-align: justify;
    }
    .text {
      font-family: "CM Serif";
      line-height: 1.5;
      font-size: 12pt;
      color: #111;
      padding: 2vw; 
    }
    .box-header {
      top: 0px;
      left: 0px;
      position: absolute;
      margin-top: 0px;
      margin: auto;
      width: 100%;     
      z-index: 999;
      font-family: "CM Typewriter";
      line-height: 1.5;
      color: #111;
      
      padding-top: 13px;
      font-weight: normal; 
      font-style: normal; 
      background-color: white;
      border-bottom: 1px solid #444;
      border-top-style: none;
      text-align: center;
    }
    .header-title {
      font-size: 20pt;
    }
    .header-quote {
      font-size: 15pt;
      color: #333;
      margin-left: 2vw;
      margin-right: 2vw;
    }
    .title {
        font-size: 8vh;
        color: #111; 
        font-family: "CM Bold";
        font-weight: normal;
        margin-top: 2vh;
        margin-bottom: 2vh;
        margin-left: 1vw;
        margin-right: 1vw;
    }
    .content {
        margin-top: 30vh;
        margin-bottom: 20vh;
        margin-left: auto;
        margin-right: auto;
        width: 250mm;
        max-width: 98%;
        background-color: black;
    }
    .background {
        z-index: -10;
        position: fixed;
        top: 0vh;
        left: 0vw;
        width: 100%;
        height: 100%;
        background-image: url("background.png");
    }
    .link {
    	color: blue;
    	text-decoration: none;
    }
    .frame {
    	max-width:100%;
    	border: 1px solid #444;
    }
  </style>
	""";
@


